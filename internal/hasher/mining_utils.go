// internal/hasher/mining_utils.go
// Utility functions for mining-based neural network operations

package hasher

import (
	"crypto/sha256"
	"encoding/binary"
)

// CRC lookup tables from Bitmain protocol
var chCRCHTalbe = [256]uint8{
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40,
}

var chCRCLTalbe = [256]uint8{
	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
	0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
	0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
	0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
	0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
	0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
	0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
	0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
	0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
	0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
	0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
	0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
	0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
	0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
	0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
	0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
	0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
	0x41, 0x81, 0x80, 0x40,
}

// CalculateCRC16 computes CRC-16 using Bitmain's Modbus-style lookup tables
func CalculateCRC16(data []byte) uint16 {
	chCRCHi := uint8(0xFF)
	chCRCLo := uint8(0xFF)

	for _, b := range data {
		wIndex := chCRCLo ^ b
		chCRCLo = chCRCHi ^ chCRCHTalbe[wIndex]
		chCRCHi = chCRCLTalbe[wIndex]
	}

	return (uint16(chCRCHi) << 8) | uint16(chCRCLo)
}

// GoldenRatio is the golden ratio constant for hash mixing (as uint32 for MIPS compatibility)
const GoldenRatio uint32 = 2654435769

// doubleSHA256 computes SHA256(SHA256(data)) - Bitcoin's hash function
func doubleSHA256(data []byte) [32]byte {
	first := sha256.Sum256(data)
	return sha256.Sum256(first[:])
}

// computeMidstate computes the SHA-256 midstate for the first 64 bytes
// This is what the ASIC actually receives for efficient mining
func computeMidstate(header []byte) [32]byte {
	if len(header) < 64 {
		padded := make([]byte, 64)
		copy(padded, header)
		header = padded
	}

	// SHA-256 processes 64 bytes at a time
	// The midstate is the internal state after processing the first block
	h := sha256.New()
	h.Write(header[:64])

	// Get the internal state (this is a simplified representation)
	// In reality, we'd need to access the hash state directly
	sum := h.Sum(nil)
	var midstate [32]byte
	copy(midstate[:], sum)
	return midstate
}

// BuildTxTaskFromHeader constructs a TxTask packet from an 80-byte mining header
// Returns the packet ready to send to the ASIC via /dev/bitmain-asic
func BuildTxTaskFromHeader(header []byte, workID uint8) []byte {
	// TxTask structure:
	// [token(1)][version(1)][length(2)][work_num(1)][ASIC_TASK(45)][crc(2)]
	// ASIC_TASK: [work_id(1)][midstate(32)][data(12)]
	//
	// Total: 51 bytes for single work item

	const (
		TokenTxTask = 0x52
		taskSize    = 45 // work_id(1) + midstate(32) + data(12)
	)

	packet := make([]byte, 4+1+taskSize+2) // 52 bytes total

	// Header (4 bytes)
	packet[0] = TokenTxTask
	packet[1] = 0x00                               // Version
	binary.LittleEndian.PutUint16(packet[2:4], 46) // Length = work_num(1) + ASIC_TASK(45)

	// work_num (1 byte)
	packet[4] = 0x01

	// ASIC_TASK (45 bytes)
	// work_id (1 byte)
	packet[5] = workID

	// midstate[32] - compute SHA-256 midstate for first 64 bytes
	midstate := computeMidstate(header)
	copy(packet[6:38], midstate[:])

	// data[12] - last 12 bytes relevant for mining
	// These are: merkle_root_suffix(4) + timestamp(4) + nBits(4)
	// From header bytes 64-75 (before nonce at 76-79)
	if len(header) >= 76 {
		copy(packet[38:50], header[64:76])
	}

	// Calculate and append CRC (covers bytes 0-49)
	crc := CalculateCRC16(packet[:50])
	binary.LittleEndian.PutUint16(packet[50:52], crc)

	return packet
}

// ParseRxNonce parses an RxNonce response from the ASIC
// Returns the work_id, nonce, and chain number
func ParseRxNonce(data []byte) (workID uint8, nonce uint32, chainNum uint8, ok bool) {
	// RxNonce structure (0xA2):
	// [data_type(1)][version(1)][length(2)][fifo_space(2)][nonce_num(1)][reserved(1)]
	// [nonce_data...]
	// Each nonce_data: [work_id(1)][nonce(4)][chain_num(1)][reserved(2)]

	if len(data) < 16 {
		return 0, 0, 0, false
	}

	// Verify data type
	if data[0] != 0xA2 {
		return 0, 0, 0, false
	}

	// Get nonce count
	nonceNum := data[6]
	if nonceNum == 0 {
		return 0, 0, 0, false
	}

	// Parse first nonce entry (offset 8)
	if len(data) < 16 {
		return 0, 0, 0, false
	}

	workID = data[8]
	nonce = binary.LittleEndian.Uint32(data[9:13])
	chainNum = data[13]

	return workID, nonce, chainNum, true
}

// MiningConfig holds configuration for mining-based operations
type MiningConfig struct {
	// Difficulty target (nBits format)
	// 0x1d00ffff = Difficulty 1 (easiest)
	// 0x1c00ffff = Difficulty ~256
	// 0x1b00ffff = Difficulty ~65536
	NBits uint32

	// Nonce search range for determinism
	NonceStart uint32
	NonceEnd   uint32

	// Timeout for mining operations (milliseconds)
	TimeoutMs int

	// Number of retries on failure
	MaxRetries int
}

// DefaultMiningConfig returns sensible defaults for LSH-style operation
func DefaultMiningConfig() MiningConfig {
	return MiningConfig{
		NBits:      0x1d00ffff, // Difficulty 1
		NonceStart: 0,
		NonceEnd:   1000000, // 1M nonce range for determinism
		TimeoutMs:  100,     // 100ms timeout
		MaxRetries: 3,
	}
}

// HashToFloat32 converts a 32-byte hash to a slice of float32 values
// Useful for using hash outputs as neural network activations
func HashToFloat32(hash [32]byte, numOutputs int) []float32 {
	outputs := make([]float32, numOutputs)

	for i := 0; i < numOutputs && i*4 < 32; i++ {
		// Read 4 bytes as uint32
		val := binary.LittleEndian.Uint32(hash[i*4 : (i+1)*4])
		// Normalize to [0, 1]
		outputs[i] = float32(val) / float32(^uint32(0))
	}

	// If more outputs needed than hash provides, use mixing
	for i := 8; i < numOutputs; i++ {
		// XOR different parts of the hash for additional outputs
		idx1 := (i * 3) % 8
		idx2 := (i * 7) % 8
		val1 := binary.LittleEndian.Uint32(hash[idx1*4 : (idx1+1)*4])
		val2 := binary.LittleEndian.Uint32(hash[idx2*4 : (idx2+1)*4])
		mixed := val1 ^ val2 ^ (uint32(i) * GoldenRatio)
		outputs[i] = float32(mixed) / float32(^uint32(0))
	}

	return outputs
}

// Float32ToBytes converts a slice of float32 to bytes (for header packing)
func Float32ToBytes(values []float32) []byte {
	result := make([]byte, len(values)*4)
	for i, v := range values {
		binary.LittleEndian.PutUint32(result[i*4:(i+1)*4], uint32(v))
	}
	return result
}

// BytesToFloat32 converts bytes back to float32 slice
func BytesToFloat32(data []byte) []float32 {
	result := make([]float32, len(data)/4)
	for i := range result {
		bits := binary.LittleEndian.Uint32(data[i*4 : (i+1)*4])
		result[i] = float32(bits)
	}
	return result
}
